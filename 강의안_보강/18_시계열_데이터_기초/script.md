# [18차시] 시계열 데이터 기초 - 강사 스크립트

## 📋 수업 개요

| 항목 | 내용 |
|------|------|
| 차시 | 18차시 |
| 주제 | 시계열 데이터 기초 |
| 시간 | 30분 (이론 15분 + 실습 13분 + 정리 2분) |
| 학습 목표 | 시계열 특성, datetime 처리, 전처리 기법 |

---

## 🎯 학습 목표

1. 시계열 데이터의 특성을 이해한다
2. Python datetime 처리를 수행한다
3. 시계열 전처리 기법을 활용한다

---

## 🕐 시간 배분

| 구간 | 시간 | 내용 |
|------|------|------|
| 도입 | 2분 | 복습 및 학습목표 |
| 대주제 1 | 5분 | 시계열 데이터 특성 |
| 대주제 2 | 5분 | datetime 처리 |
| 대주제 3 | 5분 | 전처리 기법 |
| 실습 | 11분 | 센서 시계열 분석 |
| 정리 | 2분 | 요약 및 다음 차시 예고 |

---

## 📝 상세 스크립트

### 도입부 (2분)

#### 슬라이드 1-2: 복습

> "지금까지 분류와 회귀 문제를 다뤘습니다. 하이퍼파라미터 튜닝까지 배웠죠."

> "오늘부터는 시계열 데이터를 다룹니다. 제조 현장에서 센서 데이터, 생산 기록, 설비 로그 등 시간 순서로 쌓이는 데이터가 많습니다. 이런 데이터를 어떻게 다루는지 배워봅시다."

---

#### 슬라이드 3-4: 학습 목표

> "오늘의 학습 목표는 세 가지입니다. 시계열 데이터가 뭐가 다른지 이해하고, Python에서 날짜/시간을 다루는 방법을 배우고, 시계열 전처리 기법들을 익힙니다."

---

### 대주제 1: 시계열 데이터의 특성 (5분)

#### 슬라이드 5-7: 시계열 데이터란

> "시계열 데이터는 시간 순서로 기록된 데이터입니다. 각 데이터 포인트에 타임스탬프가 있어요."

> "주식 가격, 센서 측정값, 월별 매출, 설비 로그 등이 모두 시계열 데이터입니다."

---

#### 슬라이드 8-9: 일반 데이터 vs 시계열

> "일반 데이터와 뭐가 다를까요?"

> "일반 데이터는 행이 독립입니다. 랜덤으로 섞어도 의미가 바뀌지 않아요. 하지만 시계열은 다릅니다. 순서가 있고, 섞으면 의미가 사라집니다."

> "가장 중요한 차이는 데이터 분할입니다. 일반 ML은 랜덤 분할해도 되지만, 시계열은 시간 기준으로 분할해야 합니다. 과거 데이터로 학습하고 미래 데이터로 테스트해야 해요."

---

#### 슬라이드 10-12: 시계열의 특성

> "시계열 데이터의 특성을 알아봅시다."

> "첫째, 시간 의존성입니다. 현재 값이 과거 값에 영향을 받습니다. 오늘 생산량은 어제 생산량과 관련이 있죠."

> "둘째, 자기상관입니다. 자기 자신과의 상관관계예요. 오늘 값과 어제 값이 상관관계가 있는 거죠."

> "셋째, 계절성입니다. 주기적으로 반복되는 패턴이에요. 월요일마다 불량률이 높다든지, 여름마다 에너지 사용량이 증가한다든지요."

---

#### 슬라이드 13-14: 시계열 구성요소

> "시계열 데이터는 세 가지 요소로 분해할 수 있습니다."

> "추세는 장기적인 증가/감소 경향입니다. 예를 들어 설비 노후화로 불량률이 점점 증가하는 것."

> "계절성은 일정 주기로 반복되는 패턴입니다. 오전에 생산량이 높고 오후에 낮아지는 것."

> "잔차는 추세와 계절성을 제외한 불규칙 변동입니다."

---

#### 슬라이드 15-16: 시간 기준 분할

> "시계열 예측에서 가장 중요한 건 데이터 누출을 막는 겁니다."

> "랜덤 분할을 하면 미래 데이터가 학습에 포함될 수 있어요. 이러면 실제보다 성능이 좋게 나옵니다. 하지만 실전에서는 망하죠."

> "반드시 시간 순서대로 분할하세요. 앞 70%로 학습, 뒤 30%로 테스트. 이게 정석입니다."

---

### 대주제 2: Python datetime 처리 (5분)

#### 슬라이드 17-19: datetime 모듈

> "Python에서 날짜를 다루는 기본 모듈은 datetime입니다."

```python
from datetime import datetime, timedelta

# 현재 시각
now = datetime.now()

# 특정 날짜 생성
dt = datetime(2025, 1, 5, 14, 30)

# 문자열 → datetime
dt = datetime.strptime("2025-01-05", "%Y-%m-%d")

# datetime → 문자열
s = dt.strftime("%Y년 %m월 %d일")
```

> "strptime은 문자열을 datetime으로, strftime은 datetime을 문자열로 변환합니다."

---

#### 슬라이드 20-21: 형식 코드

> "형식 코드를 외울 필요는 없어요. 많이 쓰는 것만 기억하면 됩니다."

> "%Y는 4자리 연도, %m은 2자리 월, %d는 2자리 일, %H는 24시간 형식 시간, %M은 분입니다."

---

#### 슬라이드 22-24: Pandas 날짜 처리

> "Pandas에서는 pd.to_datetime()을 씁니다."

```python
# 문자열 → datetime
df['date'] = pd.to_datetime(df['date'])
```

> "다양한 형식을 자동으로 인식합니다. '2025-01-05', '01/05/2025', 'Jan 5, 2025' 다 됩니다."

---

#### 슬라이드 25-27: dt 접근자

> "datetime 열에서 정보를 추출할 때 dt 접근자를 씁니다."

```python
df['year'] = df['date'].dt.year
df['month'] = df['date'].dt.month
df['dayofweek'] = df['date'].dt.dayofweek  # 0=월요일
df['is_weekend'] = df['date'].dt.dayofweek >= 5
```

> "이렇게 추출한 정보를 특성으로 사용하면 '월요일 효과', '계절 효과' 등을 모델이 학습할 수 있습니다."

---

### 대주제 3: 시계열 전처리 기법 (5분)

#### 슬라이드 28-30: resample() - 주기 변환

> "resample은 시간 주기를 변환합니다. 분별 데이터를 시간별로, 일별 데이터를 주별로 바꾸는 거죠."

```python
# 분별 → 시간별 평균
hourly = df.resample('H').mean()

# 일별 → 주별 합계
weekly = df.resample('W').sum()
```

> "인덱스가 DatetimeIndex여야 사용 가능합니다. df.set_index('date')로 먼저 설정하세요."

---

#### 슬라이드 31-33: rolling() - 이동 통계

> "rolling은 윈도우를 이동하며 통계를 계산합니다. 이동평균이 대표적이에요."

```python
# 7일 이동평균
df['ma_7'] = df['value'].rolling(window=7).mean()
```

> "노이즈를 제거하고 추세를 파악하는 데 유용합니다. 주가 차트에서 보던 이동평균선이 바로 이거예요."

---

#### 슬라이드 34-36: shift() - 시차 변수

> "shift는 데이터를 시간축으로 이동합니다. Lag 특성을 만들 때 필수입니다."

```python
# 1칸 뒤로 (어제 값)
df['lag_1'] = df['value'].shift(1)
```

> "오늘 생산량을 예측할 때 어제 생산량을 특성으로 쓰려면 shift(1)을 합니다."

> "**중요!** shift 없이 rolling만 하면 미래 정보가 포함됩니다. 반드시 shift(1) 후에 rolling 하세요."

---

#### 슬라이드 37-38: 데이터 누출 방지

> "가장 흔한 실수가 미래 정보 누출입니다."

```python
# ❌ 잘못됨: 오늘 값이 이동평균에 포함
df['ma_7'] = df['production'].rolling(7).mean()

# ✅ 올바름: 어제까지만 사용
df['ma_7'] = df['production'].shift(1).rolling(7).mean()
```

> "shift(1)을 먼저 해서 어제까지의 데이터만 사용하도록 하세요."

---

### 실습편 (11분)

#### 슬라이드 39-41: 데이터 생성

> "30일간 시간별 센서 데이터를 만듭니다."

```python
import pandas as pd
import numpy as np

np.random.seed(42)

dates = pd.date_range(
    start='2025-01-01',
    periods=24*30,  # 720시간
    freq='H'
)

df = pd.DataFrame({
    'timestamp': dates,
    'temperature': 85 + np.random.normal(0, 3, len(dates)),
    'production': 1000 + np.random.normal(0, 50, len(dates))
})
```

---

#### 슬라이드 42-44: datetime 처리 실습

> "날짜를 인덱스로 설정하고 정보를 추출합니다."

```python
# 인덱스 설정
df = df.set_index('timestamp')

# 날짜 특성 추출
df['hour'] = df.index.hour
df['dayofweek'] = df.index.dayofweek
df['is_weekend'] = (df.index.dayofweek >= 5).astype(int)
```

> "인덱스가 DatetimeIndex면 슬라이싱도 편합니다. df['2025-01-01':'2025-01-03']처럼요."

---

#### 슬라이드 45-47: resample, rolling 실습

> "시간별 데이터를 일별로 바꾸고, 이동평균을 계산합니다."

```python
# 일별 평균
daily = df.resample('D').mean()

# 24시간 이동평균
df['temp_ma_24'] = df['temperature'].rolling(24).mean()

# 7일 이동평균
df['prod_ma_168'] = df['production'].rolling(168).mean()
```

---

#### 슬라이드 48-50: shift로 Lag 특성

> "예측에 사용할 Lag 특성을 만듭니다."

```python
# Lag 특성
df['prod_lag_1'] = df['production'].shift(1)
df['prod_lag_24'] = df['production'].shift(24)

# Rolling 특성 (shift 먼저!)
df['ma_24'] = df['production'].shift(1).rolling(24).mean()
```

> "shift를 먼저 해서 미래 정보 누출을 방지하는 게 핵심입니다."

---

#### 슬라이드 51-53: 시간 기준 분할

> "마지막으로 시간 기준으로 학습/테스트를 나눕니다."

```python
# NaN 제거
df = df.dropna()

# 시간 기준 분할
split_date = '2025-01-25'
train = df[:split_date]
test = df[split_date:]

print(f"학습: {len(train)}, 테스트: {len(test)}")
```

> "절대 랜덤 분할하지 마세요. 시간 순서를 지켜야 합니다."

---

### 정리 (2분)

#### 슬라이드 54-55: 핵심 정리

> "오늘 배운 내용을 정리합니다."

> "시계열 데이터는 순서가 중요합니다. 랜덤 분할 금지, 시간 기준 분할 필수입니다."

> "Pandas에서 pd.to_datetime()으로 변환하고, dt 접근자로 정보를 추출합니다."

> "resample로 주기를 바꾸고, rolling으로 이동 통계를 구하고, shift로 Lag 특성을 만듭니다."

> "미래 정보 누출을 막으려면 반드시 shift(1) 후에 rolling 하세요."

---

#### 슬라이드 56-57: 다음 차시 예고

> "다음 시간에는 실제로 시계열 예측 모델을 만듭니다. 오늘 배운 특성 엔지니어링을 활용해서 ML 모델로 시계열을 예측합니다."

> "오늘 수업 마무리합니다. 수고하셨습니다!"

---

## ❓ 예상 질문 및 답변

### Q1: 왜 랜덤 분할하면 안 되나요?

> "미래 정보가 학습에 포함되기 때문입니다. 예를 들어 2월 데이터로 1월을 예측하면 '예측'이 아니라 '답지를 본 것'이죠. 실전에서는 미래를 알 수 없으니 성능이 확 떨어집니다."

### Q2: shift(1)을 꼭 해야 하나요?

> "Lag 특성이나 Rolling 특성을 만들 때는 필수입니다. 안 하면 오늘 값이 포함되어 미래 정보가 누출됩니다. 모델이 '컨닝'하는 셈이에요."

### Q3: resample과 rolling의 차이는?

> "resample은 전체 주기를 바꿉니다. 시간별 → 일별처럼요. rolling은 주기는 그대로 두고 윈도우 통계를 계산합니다. 각 행마다 이동평균 값이 붙어요."

### Q4: 이동평균 윈도우는 어떻게 정하나요?

> "도메인 지식에 따릅니다. 일별 패턴이 있으면 24시간, 주별 패턴이 있으면 7일(168시간). 여러 값을 실험해서 예측 성능을 비교하세요."

### Q5: 계절성은 어떻게 처리하나요?

> "날짜에서 hour, dayofweek, month 등을 추출해서 특성으로 씁니다. 모델이 '월요일 효과', '여름 효과' 등을 학습합니다. 사인/코사인 인코딩도 방법입니다."

---

## 📚 참고 자료

### 공식 문서
- [Pandas 시계열 기능](https://pandas.pydata.org/docs/user_guide/timeseries.html)
- [Python datetime](https://docs.python.org/3/library/datetime.html)

### 관련 차시
- 16차시: 하이퍼파라미터 튜닝
- 18차시: 시계열 예측 모델

---

## ✅ 체크리스트

수업 전:
- [ ] 시계열 데이터 예제 준비
- [ ] resample, rolling, shift 테스트

수업 중:
- [ ] 시간 기준 분할 강조
- [ ] shift(1) 필수 설명
- [ ] 데이터 누출 방지 경고

수업 후:
- [ ] 실습 코드 배포
- [ ] 시계열 예측 모델 예고
