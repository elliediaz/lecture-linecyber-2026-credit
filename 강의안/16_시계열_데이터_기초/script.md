# [16차시] 시계열 데이터 기초 - 강사 스크립트

## 강의 정보
- **차시**: 16차시 (25-30분)
- **유형**: 이론 + 실습
- **구성**: 이론 10분 + 실습 15-20분
- **대상**: 비전공자, AI 입문자, 제조업 종사자

---

## 이론편 (10분)

### 도입 (2분)

#### 인사 및 지난 시간 복습 [1분]

> 안녕하세요, 16차시를 시작하겠습니다.
>
> 지난 시간에 GridSearchCV와 RandomizedSearchCV로 최적의 하이퍼파라미터를 찾는 방법을 배웠습니다.
>
> 오늘은 **시계열 데이터**를 다루는 방법을 배웁니다. 제조 현장에서 가장 많이 다루는 데이터 형태죠.

#### 학습목표 안내 [1분]

> 오늘 수업을 마치면 다음 세 가지를 할 수 있습니다.
>
> 첫째, 시계열 데이터의 특성을 이해합니다.
> 둘째, datetime으로 날짜와 시간을 처리합니다.
> 셋째, 시계열 데이터를 시각화합니다.

---

### 핵심 내용 (8분)

#### 시계열 데이터란? [2분]

> **시계열 데이터**는 시간 순서에 따라 관측된 데이터입니다.
>
> 제조 현장 예시를 보면요.
> - 일별 생산량
> - 시간별 설비 온도
> - 분 단위 센서 데이터
> - 월별 불량률 추이
>
> 이런 데이터들의 공통점은 **시간 순서가 중요하다**는 거예요.
>
> 일반 데이터는 순서를 바꿔도 되지만, 시계열은 순서를 바꾸면 의미가 없어집니다.

#### 시계열 데이터의 특징 [1.5분]

> 시계열 데이터는 세 가지 특징이 있습니다.
>
> 첫째, **순서가 중요**합니다. 1월 데이터 다음에 2월 데이터가 와야 해요.
>
> 둘째, **시간 의존성**이 있습니다. 오늘 생산량은 어제 생산량과 관련 있죠. 이걸 자기상관이라고 합니다.
>
> 셋째, **계절성**이 있을 수 있어요. 12월 매출이 높다거나, 월요일 생산량이 낮다거나 하는 패턴이요.

#### Python 날짜/시간 처리 [2min]

> Python에서 날짜를 다루는 방법을 봅시다.
>
> ```python
> from datetime import datetime, timedelta
>
> # 현재 시간
> now = datetime.now()
>
> # 특정 날짜 생성
> date = datetime(2024, 1, 15)
>
> # 문자열 → datetime
> date = datetime.strptime('2024-01-15', '%Y-%m-%d')
> ```
>
> strptime은 문자열을 datetime으로 바꾸고, strftime은 datetime을 문자열로 바꿉니다.

#### Pandas 날짜 처리 [2.5min]

> Pandas에서는 더 편하게 날짜를 다룰 수 있어요.
>
> ```python
> # 문자열을 datetime으로
> df['날짜'] = pd.to_datetime(df['날짜'])
>
> # 날짜 정보 추출
> df['연도'] = df['날짜'].dt.year
> df['월'] = df['날짜'].dt.month
> df['요일'] = df['날짜'].dt.dayofweek
> ```
>
> **dt 접근자**를 쓰면 연도, 월, 일, 요일을 쉽게 추출할 수 있습니다.
>
> 날짜를 인덱스로 설정하면 기간 필터링이 아주 쉬워져요.
>
> ```python
> df = df.set_index('날짜')
> df['2024-01']  # 2024년 1월 전체
> ```

---

## 실습편 (15-20분)

### 실습 소개 [2분]

> 이제 실습 시간입니다. 시계열 데이터를 직접 다뤄봅니다.
>
> **실습 목표**입니다.
> 1. 날짜/시간을 처리합니다.
> 2. 날짜 정보를 추출합니다.
> 3. 리샘플링과 이동평균을 계산합니다.
> 4. 시계열을 시각화합니다.
>
> **실습 환경**을 확인해주세요.
>
> ```python
> import pandas as pd
> import numpy as np
> import matplotlib.pyplot as plt
> from datetime import datetime, timedelta
> ```

### 실습 1: 데이터 생성 [2min]

> 첫 번째 실습입니다. 일별 생산 데이터를 생성합니다.
>
> ```python
> dates = pd.date_range('2024-01-01', periods=180)
> production = 1000 + np.cumsum(np.random.randn(180) * 10)
> ```
>
> date_range로 날짜 범위를 쉽게 만들 수 있어요. 180일치 데이터를 생성했습니다.

### 실습 2: 날짜 변환 [2min]

> 두 번째 실습입니다. 문자열을 datetime으로 변환합니다.
>
> ```python
> df['날짜'] = pd.to_datetime(df['날짜'])
> print(df['날짜'].dtype)  # datetime64[ns]
> ```
>
> dtype이 datetime64로 바뀌면 성공이에요. 이제 날짜 연산이 가능합니다.

### 실습 3: 날짜 정보 추출 [2min]

> 세 번째 실습입니다. dt 접근자로 정보를 추출합니다.
>
> ```python
> df['연도'] = df.index.year
> df['월'] = df.index.month
> df['요일'] = df.index.dayofweek  # 0=월요일
> df['요일명'] = df.index.day_name()
> ```
>
> 요일은 0이 월요일, 6이 일요일이에요. 분석할 때 자주 쓰입니다.

### 실습 4: 리샘플링 [2min]

> 네 번째 실습입니다. 집계 주기를 변경합니다.
>
> ```python
> # 일별 → 주별 평균
> weekly = df['생산량'].resample('W').mean()
>
> # 일별 → 월별 합계
> monthly = df['생산량'].resample('M').sum()
> ```
>
> resample은 시계열의 주기를 바꿔줍니다. 'W'는 주간, 'M'은 월간이에요.

### 실습 5: 이동평균 [3min]

> 다섯 번째 실습입니다. rolling으로 이동평균을 계산합니다.
>
> ```python
> df['이동평균_7일'] = df['생산량'].rolling(window=7).mean()
> df['이동평균_30일'] = df['생산량'].rolling(window=30).mean()
> ```
>
> 7일 이동평균은 최근 7일의 평균입니다. 노이즈를 줄이고 추세를 볼 때 유용해요.
>
> 시각화해보면 일별 데이터보다 훨씬 부드러운 선이 나옵니다.

### 실습 6: Shift 연산 [2min]

> 여섯 번째 실습입니다. shift로 시차 변수를 만듭니다.
>
> ```python
> df['전일_생산량'] = df['생산량'].shift(1)
> df['변화량'] = df['생산량'] - df['생산량'].shift(1)
> df['변화율'] = df['생산량'].pct_change()
> ```
>
> 어제 대비 얼마나 변했는지 분석할 때 많이 씁니다. 예측 모델의 특성으로도 자주 쓰여요.

### 실습 7: 시계열 분할 주의사항 [2min]

> 마지막 실습입니다. 중요한 내용이에요.
>
> ```python
> # ❌ 잘못된 방법 (무작위 분할)
> # train_test_split(X, y, random_state=42)
>
> # ✅ 올바른 방법 (시간 기준)
> split_date = '2024-05-01'
> train = df[df.index < split_date]
> test = df[df.index >= split_date]
> ```
>
> 시계열은 **무작위 분할하면 안 됩니다**. 미래 데이터로 과거를 예측하는 꼴이 되거든요.
>
> 항상 시간 순서대로, 과거 데이터로 학습하고 미래 데이터로 테스트해야 합니다.

---

### 정리 (3분)

#### 핵심 요약 [1.5min]

> 오늘 배운 내용을 정리하겠습니다.
>
> **시계열 데이터**는 시간 순서로 관측된 데이터입니다. 순서가 중요해요.
>
> **pd.to_datetime**으로 문자열을 날짜로 변환합니다.
>
> **dt 접근자**로 연도, 월, 요일을 추출합니다.
>
> **resample**은 주기를 변경하고, **rolling**은 이동평균을 계산합니다.
>
> 시계열 분할은 반드시 **시간 기준**으로 해야 합니다.

#### 다음 차시 예고 [1min]

> 다음 17차시에서는 **시계열 예측 모델**을 배웁니다.
>
> 오늘 배운 시계열 데이터를 가지고, 미래 값을 예측하는 방법을 알아봅니다. 특성 엔지니어링과 시계열 예측 기법을 다룹니다.

#### 마무리 [0.5min]

> 시간에 따라 변하는 데이터를 다루는 법을 배웠습니다. 수고하셨습니다!

---

## 강의 노트

### 준비물
- PPT 슬라이드 (slides.md)
- 실습 코드 파일 (code.py)

### 주의사항
- datetime vs pd.to_datetime 차이 설명
- dt 접근자 사용법 강조
- 시계열 분할 주의사항 반드시 언급

### 예상 질문
1. "resample과 groupby 차이가 뭔가요?"
   → resample은 시계열 전용, 날짜 인덱스 필요. groupby는 범용

2. "rolling의 window를 몇으로 해야 하나요?"
   → 데이터 특성에 따라 다름. 일별이면 7(주간), 30(월간) 많이 사용

3. "NaN이 왜 생기나요?"
   → rolling, shift 시 처음 몇 개는 계산 불가. dropna() 사용

4. "시계열 분할 비율은 어떻게 정하나요?"
   → 보통 80:20 또는 시점 기준. 충분한 테스트 기간 확보 중요
